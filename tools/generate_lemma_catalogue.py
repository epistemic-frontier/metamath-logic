import sys
from pathlib import Path
import re

ROOT = Path(__file__).resolve().parents[2]
sys.path.append(str(ROOT / "metamath-logic" / "src"))
sys.path.append(str(ROOT / "metamath-prelude" / "src"))
sys.path.append(str(ROOT / "proof-scaffold" / "src"))

from logic.propositional.hilbert import (
    SETMM_TO_HILBERT_AXIOMS,
    SETMM_TO_HILBERT_RULES,
)
from logic.propositional.hilbert.theorems import SETMM_TO_HILBERT_LEMMAS

setmm_path = ROOT / "metamath" / "set.mm"
out_path = ROOT / "metamath-logic" / "LEMMA_CATALOGUE.md"
comments_out_path = (
    ROOT
    / "metamath-logic"
    / "src"
    / "logic"
    / "propositional"
    / "hilbert"
    / "setmm_comments.py"
)

lines = []
if setmm_path.exists():
    with setmm_path.open("r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

def _extract_comment_blocks() -> dict[str, str]:
    needed_labels: set[str] = {
        *SETMM_TO_HILBERT_AXIOMS.keys(),
        *SETMM_TO_HILBERT_RULES.keys(),
        *SETMM_TO_HILBERT_LEMMAS.keys(),
    }
    label_pat = re.compile(r"^\s*([^\s]+)\s+\$(?:a|p|f|e)\b")

    in_comment = False
    buf: list[str] = []
    pending_comment: str | None = None
    out: dict[str, str] = {}

    def finalize_comment() -> None:
        nonlocal pending_comment, buf
        text = "".join(buf)
        text = "\n".join(line.rstrip() for line in text.splitlines()).strip()
        pending_comment = text if text else None
        buf = []

    for ln in lines:
        if not in_comment:
            start = ln.find("$(")
            if start != -1:
                in_comment = True
                rest = ln[start + 2 :]
                end = rest.find("$)")
                if end != -1:
                    buf.append(rest[:end])
                    in_comment = False
                    finalize_comment()
                else:
                    buf.append(rest)
        else:
            end = ln.find("$)")
            if end != -1:
                buf.append(ln[:end])
                in_comment = False
                finalize_comment()
            else:
                buf.append(ln)

        m = label_pat.match(ln)
        if m is not None:
            label = m.group(1)
            if label in needed_labels and pending_comment is not None and label not in out:
                out[label] = pending_comment
            pending_comment = None

    return out

def find_label_line(label: str) -> int | None:
    pat = re.compile(rf"^\s*{re.escape(label)}\s+\$(?:a|p|f|e)\b")
    for i, ln in enumerate(lines, start=1):
        if pat.search(ln):
            return i
    return None

rows: list[tuple[str, str, str, str, str]] = []
for k, v in sorted(SETMM_TO_HILBERT_AXIOMS.items()):
    ln = find_label_line(k)
    link = f"file://{setmm_path}#L{ln}" if ln else f"file://{setmm_path}"
    rows.append((k, v, "Axiom", link, "✔️ 实现"))
for k, v in sorted(SETMM_TO_HILBERT_RULES.items()):
    ln = find_label_line(k)
    link = f"file://{setmm_path}#L{ln}" if ln else f"file://{setmm_path}"
    rows.append((k, v, "Rule", link, "✔️ 实现"))
for k, ctor in sorted(SETMM_TO_HILBERT_LEMMAS.items()):
    ln = find_label_line(k)
    link = f"file://{setmm_path}#L{ln}" if ln else f"file://{setmm_path}"
    rows.append((k, getattr(ctor, "__name__", str(ctor)), "Lemma", link, "✔️ 实现"))

md: list[str] = []
md.append("# Lemma Catalogue")
md.append("")
md.append("| set.mm 标签 | 本地名称/函数 | 类别 | set.mm 链接 | 状态 |")
md.append("|-------------|----------------|------|-------------|------|")
for k, v, cat, link, st in rows:
    md.append(f"| {k} | {v} | {cat} | {link} | {st} |")
content = "\n".join(md) + "\n"
out_path.write_text(content, encoding="utf-8")

comments = _extract_comment_blocks()
py_lines: list[str] = []
py_lines.append('"""Upstream set.mm comment blocks (docstring form).')
py_lines.append("")
py_lines.append("This module is auto-generated by tools/generate_lemma_catalogue.py.")
py_lines.append("It preserves the original set.mm comment blocks for credit/attribution,")
py_lines.append("but stores them as docstrings so docs and code live together.")
py_lines.append('"""')
py_lines.append("")
py_lines.append("from __future__ import annotations")
py_lines.append("")
py_lines.append("import inspect")
py_lines.append("from collections.abc import Callable")
py_lines.append("")
py_lines.append("")
py_lines.append("def _doc(fn: Callable[[], str]) -> str:")
py_lines.append('    return inspect.cleandoc(fn.__doc__ or "")')
py_lines.append("")
py_lines.append("")
label_to_ident: dict[str, str] = {}
seen_idents: set[str] = set()
for label in sorted(comments):
    ident = re.sub(r"[^0-9A-Za-z_]+", "_", label)
    if not ident or ident[0].isdigit():
        ident = f"l_{ident}"
    base = ident
    i = 2
    while ident in seen_idents:
        ident = f"{base}_{i}"
        i += 1
    seen_idents.add(ident)
    label_to_ident[label] = ident

for label in sorted(comments):
    ident = label_to_ident[label]
    doc = comments[label]
    doc = doc.replace('"""', '\\"""')
    py_lines.append(f"def {ident}() -> str:")
    py_lines.append('    """')
    for ln in doc.splitlines():
        py_lines.append(f"    {ln.rstrip()}")
    py_lines.append('    """')
    py_lines.append(f"    return _doc({ident})")
    py_lines.append("")
    py_lines.append("")

py_lines.append("LABEL_TO_FN: dict[str, Callable[[], str]] = {")
for label in sorted(comments):
    ident = label_to_ident[label]
    py_lines.append(f"    {label!r}: {ident},")
py_lines.append("}")
py_lines.append("")
py_lines.append("")
py_lines.append("def get(label: str) -> str:")
py_lines.append("    fn = LABEL_TO_FN[label]")
py_lines.append("    return _doc(fn)")
py_lines.append("")
py_lines.append("")
py_lines.append('__all__ = ["LABEL_TO_FN", "get"]')
py_content = "\n".join(py_lines) + "\n"
comments_out_path.write_text(py_content, encoding="utf-8")
